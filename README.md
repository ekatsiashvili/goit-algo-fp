# goit-algo-fp
### ФІНАЛЬНИЙ ПРОЄКТ

# Завдання 6
## Висновки з результатів роботи жадібного алгоритму та алгоритму динамічного програмування

### Жадібний алгоритм:

- Жадібний алгоритм сортує предмети за спаданням співвідношення калорій до вартості і вибирає предмети в такому порядку, поки бюджет дозволяє.
- Цей підхід швидкий і простий для реалізації. Часова складність сортування — O(n log n), де n — кількість предметів.
- Однак він не завжди гарантує оптимальний результат. Жадібний алгоритм може пропустити комбіновані рішення, які дають більшу загальну калорійність, оскільки він не розглядає всі можливі комбінації предметів.

### Алгоритм динамічного програмування:

- Алгоритм динамічного програмування створює таблицю, яка зберігає максимальну кількість калорій для кожної можливої вартості до заданого бюджету.
- Цей підхід гарантує оптимальне рішення, оскільки розглядає всі можливі комбінації предметів для досягнення максимальної калорійності в межах бюджету.
- Часова складність алгоритму — O(n * B), де n — кількість предметів, а B — бюджет. Це може бути більш повільним, ніж жадібний алгоритм, особливо для великих бюджетів і великої кількості предметів.

### Приклад результатів:

```python
items = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350}
}

budget = 100

# Жадібний алгоритм
selected_items_greedy, total_cost_greedy, total_calories_greedy = greedy_algorithm(items, budget)
print("Жадібний алгоритм:")
print("Обрані предмети:", selected_items_greedy)
print("Загальна вартість:", total_cost_greedy)
print("Загальна калорійність:", total_calories_greedy)

# Динамічне програмування
selected_items_dp, total_cost_dp, total_calories_dp = dynamic_programming(items, budget)
print("\nДинамічне програмування:")
print("Обрані предмети:", selected_items_dp)
print("Загальна вартість:", total_cost_dp)
print("Загальна калорійність:", total_calories_dp)
```

### Припустимо, ми отримали такі результати:

### Жадібний алгоритм:
- Обрані предмети: ['potato', 'cola', 'pepsi']
- Загальна вартість: 50 + 15 + 10 = 75
- Загальна калорійність: 350 + 220 + 100 = 670
  
### Динамічне програмування:
- Обрані предмети: ['hamburger', 'potato', 'pepsi']
- Загальна вартість: 40 + 25 + 10 = 75
- Загальна калорійність: 250 + 350 + 100 = 700
  
### Висновок:

- Жадібний алгоритм вибрав предмети на суму 75 одиниць, але пропустив потенційно кращі комбінації.
- Алгоритм динамічного програмування знайшов оптимальну комбінацію предметів, що забезпечує максимальну калорійність в межах того ж бюджету.
- Таким чином, для завдань, де потрібно знайти найкращу комбінацію з максимальною сумарною характеристикою (калорійністю в даному випадку),
алгоритм динамічного програмування є кращим вибором. Однак, якщо потрібно швидке і наближене рішення, жадібний алгоритм може бути досить ефективним.


# Завдання 7

## Висновки

### Висока точність методу Монте-Карло
Різниця між імовірностями, отриманими методом Монте-Карло, та теоретичними імовірностями, є дуже малою.
Це показує, що метод Монте-Карло може дуже точно оцінювати імовірності, особливо при великій кількості симуляцій (в даному випадку 1 000 000).

### Спостереження щодо кожної суми
- Найбільша теоретична імовірність випадає на суму 7 (16.67%), і ця імовірність найбільш точно відображена в результатах Монте-Карло (16.66%).
- Для інших сум різниця між результатами симуляції та теоретичними значеннями також дуже мала, що свідчить про високу точність симуляції.

### Сумарні імовірності
- Суми 2 і 12 мають найменші імовірності, як у теоретичній моделі, так і в результатах симуляції.
- Інші імовірності також дуже близькі до теоретичних значень, що демонструє відповідність симуляційного методу класичній теорії імовірностей.

### Порівняння

| Сума | Монте-Карло | Теоретична |
|------|--------------|-------------|
| Сума 2 | 0.02764 (2.764%) | 0.02778 (2.778%) |
| Сума 3 | 0.05560 (5.560%) | 0.05556 (5.556%) |
| Сума 4 | 0.08309 (8.309%) | 0.08333 (8.333%) |
| Сума 5 | 0.11145 (11.145%) | 0.11111 (11.111%) |
| Сума 6 | 0.13909 (13.909%) | 0.13889 (13.889%) |
| Сума 7 | 0.16660 (16.660%) | 0.16667 (16.667%) |
| Сума 8 | 0.13847 (13.847%) | 0.13889 (13.889%) |
| Сума 9 | 0.11126 (11.126%) | 0.11111 (11.111%) |
| Сума 10 | 0.08328 (8.328%) | 0.08333 (8.333%) |
| Сума 11 | 0.05579 (5.579%) | 0.05556 (5.556%) |
| Сума 12 | 0.02774 (2.774%) | 0.02778 (2.778%) |

### Висновок
Метод Монте-Карло в даному випадку дав результати, які дуже близькі до теоретичних значень імовірностей для сум при киданні двох кубиків. 
Це підтверджує, що метод Монте-Карло є ефективним інструментом для оцінки імовірностей у задачах, де аналітичний розрахунок може бути складним або недоступним.
Відхилення між результатами симуляції і теоретичними значеннями є мінімальними і не мають значного впливу на загальну картину.

